PENSE-BÊTE POUR L'USAGE DES INPUTS DANS UNE SCENE

scene->data[0]->angle += 2;
if (input->keys[SDL_SCANCODE_UP]) {
    scene->data[0]->y--;
} else if (input->keys[SDL_SCANCODE_DOWN]) {
    scene->data[0]->y++;
}
======================================================================
ALGORITHME DE PLACEMENT D'UNE TUILE SUR LE PLATEAU

// plateau grid de largeur c et de hauteur l
// tuile tile
//pinit : position sur le plateau de où on veut placer la tuile
//pi: position sur le plateau de la i-eme case de la tuile
for(int i=0; i<8; i++) {
    int pi = pinit + i%3 +(i/3)*c;
    // NB : vérifier les cas de débordements avant de mettre à jour le plateau (4 cas !!!)
    grid[pi] = tile[i];
}
=====================================================================
CODE CONCERNANT LA VERIFICATION D'UNE TUILE ET LES ENVIES DE SUICIDE DE LORNA non:) si

int main() {
    int XisFalse=0,ligneplateau=1,colonneplateau=2,pi,pinit,i=0;//enlever les valeurs de ligneplateau et colonneplateau pour les remplacer par celles choisis par le joueur
    int c=4,l=4; //valeur a remplacer par celles du plateau
    char tuile[9]={'X',' ',' ','1',' ','1',' ',' ','1'};//valeurs test
    char plateau[16]={'X','1',' ',' ',' ',' ',' ','1','X',' ',' ',' ',' ','1',' ',' '};// valeurs test
    do{
                printf("quelle tuile voulez vous placer?(entre 1 et 5)\n");
                scanf("%d",&numTuile);
            }while(numTuile<1||numTuile>5);
            do {
                printf("ligne ou voulez vous placer la case sup gauche de la tuile\n ");
                scanf("%d", &ligneplateau);
            }while(ligneplateau<0||ligneplateau>c);
            do{
                printf("colonne ou voulez vous placer la case sup gauche de la tuile\n");
                scanf("%d", &colonneplateau);
            }while (colonneplateau<0||colonneplateau>l);

    pinit = (colonneplateau-1) + (ligneplateau -1)*c; //initialise la position p1 dans lquelle on vient placer t1 (meme valeur pour tout le programme

    //la boucle for ci dessous permet de verifier que tous les X sont placer sur un '1' (voir pour les autres nombres){commence par regarder si une case d'une tuile est égal à X

    // si c'est le case ça regarde si la case pi correspondante est égal à '1' et si c'est différent cela met le compteur Xisfalse à 1;
    for (i = 0; i <= 8; i++) {

        pi = pinit + i % 3 + (i / 3) * c;//modifie la valeur de pi
        if (tuile[i] == 'X') {
        if (plateau[pi] != '1') {
            XisFalse = 1;
        }
        }

    }
    if(XisFalse==0) {//si Xisfalse est égal à 0 cela veut dire que tous les X sont placés sur des nombres donc on peut enchainer avec la suite du programme
        for (int j = 0; j <= 8; j++) {//meme debut que avant
            pi = pinit + j % 3 + (j / 3) * c;
            switch (plateau[pi]) {//en fonction de la valeur du plateau on modifie les données du plateau
                case 'X': //si la case du plateau =X ras
                    break;
                case '1':
                    if (tuile[j - 1] == 'X') {
                        plateau[pi] = 'X';

                    } else {
                        plateau[pi] = plateau[pi] + tuile[j - 1] - 48;
                    }
                    break;
                case ' ':
                    plateau[pi] = tuile[j];
                    break;
                case '2':
                    if (tuile[j] == 'X') {
                        plateau[pi] = 'X';
                    } else {
                        plateau[pi] = plateau[pi] + tuile[j] - 48;
                    }
                    break;
                default:
                break;

            }

        }

afficher(plateau, c, l);

// IMPORTANT// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//X==> penser a generer une nouvelle tuile

//

    }
        else{//si Xisfalse est égal à1 le placement est faux

        printf("placement incorrect");

            }

return 0;

}

===========================================================================================================
ALGORITHME DE GENERATION DE TUILE

void afficher(char tab[], int w, int h){          // tab[] = *tab
    for (int i=0; i<(w*h); i++){
        if ((i%w) == 0){
            printf("\n");
        }
        printf("(%c)", tab[i]);
    }
}

int isInIndex(const int *tab, int e) {
    int i=0;
    int res=0;
    while(i<3 || res) {
        if(tab[i] == e) {
            res = 1;
        }
        i++;
    }
    return res;
}

void estdedans(char **tuile, int x, int y, int w, int h) {
    for (int i=0; i<=2; i++){
        for (int j=0; j<=2; j++){
            printf("a");
            //printf("%c", tuile[i][j]);
            if (tuile[i][j] == 0) {
                //continue;
            } else {
                if(y+i>=0 && y+i<=h+2){
                    if (x+j>=0 && x+j<=w+2){
                        printf("Le motif est dans la grille");
                    }
                }
            }
        }
    }
}

int main (){
    int w, h;
    srand(time(0));
/*
    printf("Veuillez rentrer le nombre de colonnes du tableau");
    scanf("%d", &w);
    printf("Veuillez rentrer le nombre de lignes du tableau");
    scanf("%d", &h);

    char *tab = (char*) malloc(sizeof(char) * w * h);
    for (int i=0; i<(w*h);i++){
        tab[i]=0;
    }
    afficher(tab,w,h);

    char *tab1 = (char*) malloc(sizeof(char) * 9);
    for (int i=0; i<9;i++){
        tab1[i]=0;
    }

    int chiffre=rand()%9;
    tab1[chiffre]='X';

    int combien=rand()%3+1;
    int index[combien];

    for(int i=0; i<combien; i++) {
        int marcel=rand()%9;
        while(marcel == chiffre) { //|| isInIndex(index, marcel, combien)) {
            marcel=rand()%9;
        }
        index[i]=marcel;
        tab1[index[i]]=1;
    }

    afficher(tab1,3,3);

    free(tab1);*/

    char tuile[3][3] = {{0,1,0},{0,0,0},{0,0,0}};


    estdedans((char **) tuile, 1, 1, 5, 5);



    return 0;
}